/*
 * Tapis Files API
 *
 * The Tapis Files API provides for management of file resources on Tapis systems
 *
 * The version of the OpenAPI document: 1.8.2
 * Contact: cicsupport@tacc.utexas.edu
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_post_it`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePostItError {
    Status400(models::FileStringResponse),
    Status401(models::FileStringResponse),
    Status403(models::FileStringResponse),
    Status404(models::FileStringResponse),
    Status500(models::FileStringResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_post_it`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeletePostItError {
    Status400(models::FileStringResponse),
    Status401(models::FileStringResponse),
    Status403(models::FileStringResponse),
    Status404(models::FileStringResponse),
    Status500(models::FileStringResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_post_it`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPostItError {
    Status400(models::FileStringResponse),
    Status401(models::FileStringResponse),
    Status403(models::FileStringResponse),
    Status404(models::FileStringResponse),
    Status500(models::FileStringResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_post_its`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPostItsError {
    Status400(models::FileStringResponse),
    Status401(models::FileStringResponse),
    Status403(models::FileStringResponse),
    Status404(models::FileStringResponse),
    Status500(models::FileStringResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`redeem_post_it`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RedeemPostItError {
    Status400(models::FileStringResponse),
    Status403(models::FileStringResponse),
    Status404(models::FileStringResponse),
    Status500(models::FileStringResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_post_it`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdatePostItError {
    Status400(models::FileStringResponse),
    Status401(models::FileStringResponse),
    Status403(models::FileStringResponse),
    Status404(models::FileStringResponse),
    Status500(models::FileStringResponse),
    UnknownValue(serde_json::Value),
}


/// Create a PostIt.  The PostIt will grant access to a file url. The newly created PostIt can be redeemed by anyone without  further authorization.  This will nearly identical to calling the files service getContents endpoint. 
pub async fn create_post_it(configuration: &configuration::Configuration, system_id: &str, path: &str, create_post_it_request: models::CreatePostItRequest) -> Result<models::PostItResponse, Error<CreatePostItError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;
    let p_path_path = path;
    let p_body_create_post_it_request = create_post_it_request;

    let uri_str = format!("{}/v3/files/postits/{systemId}/{path}", configuration.base_path, systemId=crate::apis::urlencode(p_path_system_id), path=crate::apis::urlencode(p_path_path));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_create_post_it_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PostItResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PostItResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreatePostItError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a PostIt.
pub async fn delete_post_it(configuration: &configuration::Configuration, postit_id: &str) -> Result<models::RespChangeCount, Error<DeletePostItError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_postit_id = postit_id;

    let uri_str = format!("{}/v3/files/postits/{postitId}", configuration.base_path, postitId=crate::apis::urlencode(p_path_postit_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespChangeCount`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespChangeCount`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeletePostItError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a single PostIt.  This does not redeem the PostIt.
pub async fn get_post_it(configuration: &configuration::Configuration, postit_id: &str) -> Result<models::PostItResponse, Error<GetPostItError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_postit_id = postit_id;

    let uri_str = format!("{}/v3/files/postits/{postitId}", configuration.base_path, postitId=crate::apis::urlencode(p_path_postit_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PostItResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PostItResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPostItError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a list of all PostIts.  Use *listType* and *select* query  parameters to limit results. Query parameter *listType* allows for filtering  results based on authorization. Options for *listType* are   - *OWNED* Include only items owned by requester (Default)   - *ALL* Include all items requester is authorized to view. (Tenant admins can view all PostIts in their tenant). 
pub async fn list_post_its(configuration: &configuration::Configuration, list_type: Option<models::ListTypeEnum>, limit: Option<i32>, order_by: Option<&str>, skip: Option<i32>, start_after: Option<&str>, select: Option<&str>) -> Result<models::PostItListResponse, Error<ListPostItsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_list_type = list_type;
    let p_query_limit = limit;
    let p_query_order_by = order_by;
    let p_query_skip = skip;
    let p_query_start_after = start_after;
    let p_query_select = select;

    let uri_str = format!("{}/v3/files/postits", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_list_type {
        req_builder = req_builder.query(&[("listType", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_by {
        req_builder = req_builder.query(&[("orderBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_after {
        req_builder = req_builder.query(&[("startAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_select {
        req_builder = req_builder.query(&[("select", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PostItListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PostItListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListPostItsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Redeem a PostIt.  This will return the file that is pointed to by the PostIt.  No authentication is required. If the *zip* query param is provided it controls if the content is zipped or not.  If zip is not provided, it defaults to false unless the path pointed to by the PostIt is a directory.  In the case of a directory, the default is zip=true. Directories must by redeemed in zipped format, so either accept the default, or specify zip=true.
pub async fn redeem_post_it(configuration: &configuration::Configuration, postit_id: &str, zip: Option<bool>, download: Option<bool>) -> Result<(), Error<RedeemPostItError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_postit_id = postit_id;
    let p_query_zip = zip;
    let p_query_download = download;

    let uri_str = format!("{}/v3/files/postits/redeem/{postitId}", configuration.base_path, postitId=crate::apis::urlencode(p_path_postit_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_zip {
        req_builder = req_builder.query(&[("zip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_download {
        req_builder = req_builder.query(&[("download", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RedeemPostItError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update selected fields of a PostIt.  
pub async fn update_post_it(configuration: &configuration::Configuration, postit_id: &str, update_post_it_request: models::UpdatePostItRequest) -> Result<models::PostItResponse, Error<UpdatePostItError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_postit_id = postit_id;
    let p_body_update_post_it_request = update_post_it_request;

    let uri_str = format!("{}/v3/files/postits/{postitId}", configuration.base_path, postitId=crate::apis::urlencode(p_path_postit_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_update_post_it_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PostItResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PostItResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdatePostItError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

