/*
 * Tapis Files API
 *
 * The Tapis Files API provides for management of file resources on Tapis systems
 *
 * The version of the OpenAPI document: 1.8.2
 * Contact: cicsupport@tacc.utexas.edu
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteError {
    Status400(models::FileStringResponse),
    Status401(models::FileStringResponse),
    Status403(models::FileStringResponse),
    Status404(models::FileStringResponse),
    Status500(models::FileStringResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_facl`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFaclError {
    Status401(models::FileStringResponse),
    Status403(models::FileStringResponse),
    Status404(models::FileStringResponse),
    Status500(models::FileStringResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_stat_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStatInfoError {
    Status400(models::FileStringResponse),
    Status401(models::FileStringResponse),
    Status403(models::FileStringResponse),
    Status404(models::FileStringResponse),
    Status500(models::FileStringResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`insert`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InsertError {
    Status400(models::FileStringResponse),
    Status401(models::FileStringResponse),
    Status403(models::FileStringResponse),
    Status500(models::FileStringResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_files`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFilesError {
    Status400(models::FileStringResponse),
    Status401(models::FileStringResponse),
    Status403(models::FileStringResponse),
    Status404(models::FileStringResponse),
    Status500(models::FileStringResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mkdir`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MkdirError {
    Status400(models::FileStringResponse),
    Status401(models::FileStringResponse),
    Status403(models::FileStringResponse),
    Status500(models::FileStringResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`move_copy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MoveCopyError {
    Status400(models::FileStringResponse),
    Status401(models::FileStringResponse),
    Status403(models::FileStringResponse),
    Status404(models::FileStringResponse),
    Status500(models::FileStringResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`run_linux_native_op`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RunLinuxNativeOpError {
    Status400(models::FileStringResponse),
    Status401(models::FileStringResponse),
    Status403(models::FileStringResponse),
    Status404(models::FileStringResponse),
    Status500(models::FileStringResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_facl`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetFaclError {
    Status400(models::FileStringResponse),
    Status401(models::FileStringResponse),
    Status403(models::FileStringResponse),
    Status404(models::FileStringResponse),
    Status500(models::FileStringResponse),
    UnknownValue(serde_json::Value),
}

/// Delete a file, directory or object on {systemID} at path {path}.  For a LINUX directory this will be a recursive delete.  For an S3 system, the path will represent either a single object or all objects in the bucket with a prefix matching the system *rootDir* if the path is the empty string.  **WARNING** For an S3 system if the path is the empty string, then all objects in the bucket with a key matching the prefix *rootDir* will be deleted. So if the *rootDir* is also the empty string, then all objects in the bucket will be removed.
pub async fn delete(
    configuration: &configuration::Configuration,
    system_id: &str,
    path: &str,
) -> Result<models::FileStringResponse, Error<DeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;
    let p_path_path = path;

    let uri_str = format!(
        "{}/v3/files/ops/{systemId}/{path}",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id),
        path = crate::apis::urlencode(p_path_path)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileStringResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileStringResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get file ACLs for files or directories for a system of type LINUX.
pub async fn get_facl(
    configuration: &configuration::Configuration,
    system_id: &str,
    path: &str,
) -> Result<models::NativeLinuxGetFaclResponse, Error<GetFaclError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;
    let p_path_path = path;

    let uri_str = format!(
        "{}/v3/files/utils/linux/facl/{systemId}/{path}",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id),
        path = crate::apis::urlencode(p_path_path)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NativeLinuxGetFaclResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NativeLinuxGetFaclResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFaclError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get native stat information for a file or directory for a system of type LINUX.
pub async fn get_stat_info(
    configuration: &configuration::Configuration,
    system_id: &str,
    path: &str,
    follow_links: Option<bool>,
) -> Result<models::FileStatInfoResponse, Error<GetStatInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;
    let p_path_path = path;
    let p_query_follow_links = follow_links;

    let uri_str = format!(
        "{}/v3/files/utils/linux/{systemId}/{path}",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id),
        path = crate::apis::urlencode(p_path_path)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_follow_links {
        req_builder = req_builder.query(&[("followLinks", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileStatInfoResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileStatInfoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetStatInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// The file or object will be uploaded at the {path} independent of the original name.
pub async fn insert(
    configuration: &configuration::Configuration,
    system_id: &str,
    path: &str,
    file: std::path::PathBuf,
) -> Result<models::FileStringResponse, Error<InsertError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;
    let p_path_path = path;
    let p_form_file = file;

    let uri_str = format!(
        "{}/v3/files/ops/{systemId}/{path}",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id),
        path = crate::apis::urlencode(p_path_path)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    let mut multipart_form = reqwest::multipart::Form::new();
    multipart_form = multipart_form.file("file", p_form_file.as_os_str()).await?;
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileStringResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileStringResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InsertError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List files or objects on a Tapis system. Type for items will depend on system type. For example, for LINUX they will be posix files and for S3 they will be storage objects. For S3 the recurse flag is ignored and all objects with keys matching the path as a prefix are included.  For system types that support directory hierarchies the maximum recursion depth is 20.  Note that S3 buckets do not have a hierarchical structure. There are no directories. Everything is an object associated with a key.  Certain services may use the query parameter *impersonationId* to be used in place of the requesting Tapis user. Tapis will use this user Id when performing authorization and resolving the *effectiveUserId* for the system.  Certain services may use the query parameter *sharedCtx* to indicate that the request is in a shared context. *sharedCtx* must be set to the share grantor. Tapis will include the share grantor as part of authorization checks.
pub async fn list_files(
    configuration: &configuration::Configuration,
    system_id: &str,
    path: &str,
    pattern: Option<&str>,
    limit: Option<i32>,
    offset: Option<i64>,
    recurse: Option<bool>,
    impersonation_id: Option<&str>,
    shared_ctx: Option<&str>,
) -> Result<models::FileListingResponse, Error<ListFilesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;
    let p_path_path = path;
    let p_query_pattern = pattern;
    let p_query_limit = limit;
    let p_query_offset = offset;
    let p_query_recurse = recurse;
    let p_query_impersonation_id = impersonation_id;
    let p_query_shared_ctx = shared_ctx;

    let uri_str = format!(
        "{}/v3/files/ops/{systemId}/{path}",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id),
        path = crate::apis::urlencode(p_path_path)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_pattern {
        req_builder = req_builder.query(&[("pattern", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_recurse {
        req_builder = req_builder.query(&[("recurse", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_impersonation_id {
        req_builder = req_builder.query(&[("impersonationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_shared_ctx {
        req_builder = req_builder.query(&[("sharedCtx", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileListingResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileListingResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListFilesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a directory on the system at the given path. Not supported for all system types. Currently supported for LINUX, IRODS and GLOBUS type systems.  Certain services may use the query parameter *sharedCtx* to indicate that the request is in a shared context. *sharedCtx* must be set to the share grantor. Tapis will include the share grantor as part of authorization checks.  If the path already exists as a directory, no error will be returned.
pub async fn mkdir(
    configuration: &configuration::Configuration,
    system_id: &str,
    shared_ctx: Option<&str>,
    mkdir_request: Option<models::MkdirRequest>,
) -> Result<models::FileStringResponse, Error<MkdirError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;
    let p_query_shared_ctx = shared_ctx;
    let p_body_mkdir_request = mkdir_request;

    let uri_str = format!(
        "{}/v3/files/ops/{systemId}",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_shared_ctx {
        req_builder = req_builder.query(&[("sharedCtx", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_mkdir_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileStringResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileStringResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MkdirError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Move or copy a file, directory or object on {systemID} at path {path}. Not all operations supported for all system types.
pub async fn move_copy(
    configuration: &configuration::Configuration,
    system_id: &str,
    path: &str,
    move_copy_request: Option<models::MoveCopyRequest>,
) -> Result<models::FileStringResponse, Error<MoveCopyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;
    let p_path_path = path;
    let p_body_move_copy_request = move_copy_request;

    let uri_str = format!(
        "{}/v3/files/ops/{systemId}/{path}",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id),
        path = crate::apis::urlencode(p_path_path)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_move_copy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileStringResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileStringResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MoveCopyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Run a native operation on a path. Operations are chmod, chown or chgrp. For a system of type LINUX.
pub async fn run_linux_native_op(
    configuration: &configuration::Configuration,
    system_id: &str,
    path: &str,
    recursive: Option<bool>,
    native_linux_op_request: Option<models::NativeLinuxOpRequest>,
) -> Result<models::NativeLinuxOpResultResponse, Error<RunLinuxNativeOpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;
    let p_path_path = path;
    let p_query_recursive = recursive;
    let p_body_native_linux_op_request = native_linux_op_request;

    let uri_str = format!(
        "{}/v3/files/utils/linux/{systemId}/{path}",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id),
        path = crate::apis::urlencode(p_path_path)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_recursive {
        req_builder = req_builder.query(&[("recursive", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_native_linux_op_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NativeLinuxOpResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NativeLinuxOpResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RunLinuxNativeOpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Set file ACLs for files or directories for a system of type LINUX.  This can be used for a single file or directory, or can be recursive.  If recursion is used, it can be made to follow symlinks, or not follow symlinks.  The operations support adding or removing Acl Entries as well as removing all acls or all default acls
pub async fn set_facl(
    configuration: &configuration::Configuration,
    system_id: &str,
    path: &str,
    native_linux_set_facl_request: models::NativeLinuxSetFaclRequest,
) -> Result<models::NativeLinuxSetFaclResponse, Error<SetFaclError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;
    let p_path_path = path;
    let p_body_native_linux_set_facl_request = native_linux_set_facl_request;

    let uri_str = format!(
        "{}/v3/files/utils/linux/facl/{systemId}/{path}",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id),
        path = crate::apis::urlencode(p_path_path)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_native_linux_set_facl_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NativeLinuxSetFaclResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NativeLinuxSetFaclResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetFaclError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
