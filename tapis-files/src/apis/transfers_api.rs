/*
 * Tapis Files API
 *
 * The Tapis Files API provides for management of file resources on Tapis systems
 *
 * The version of the OpenAPI document: 1.8.2
 * Contact: cicsupport@tacc.utexas.edu
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`cancel_transfer_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelTransferTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_transfer_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTransferTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recent_transfer_tasks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecentTransferTasksError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transfer_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransferTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transfer_task_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransferTaskDetailsError {
    UnknownValue(serde_json::Value),
}

/// Request that a transfer task be cancelled.
pub async fn cancel_transfer_task(
    configuration: &configuration::Configuration,
    transfer_task_id: &str,
) -> Result<models::StringResponse, Error<CancelTransferTaskError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_transfer_task_id = transfer_task_id;

    let uri_str = format!(
        "{}/v3/files/transfers/{transferTaskId}",
        configuration.base_path,
        transferTaskId = crate::apis::urlencode(p_path_transfer_task_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StringResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StringResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelTransferTaskError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a background task which will transfer files between systems. Note that not all combinations of system types are supported. For example, transfers involving a GLOBUS system must be GLOBUS to GLOBUS.    Transfers will fail if there are more than a set number of files per directory.  The current limit is  10,000 files, however that could change in the future.  It's recommended that for large numbers of files you build an archive (tar, zip, etc) and transfer that instead.
pub async fn create_transfer_task(
    configuration: &configuration::Configuration,
    req_transfer: models::ReqTransfer,
) -> Result<models::TransferTaskResponse, Error<CreateTransferTaskError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_transfer = req_transfer;

    let uri_str = format!("{}/v3/files/transfers", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_transfer);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TransferTaskResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TransferTaskResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTransferTaskError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of transfer tasks starting with the most recent.
pub async fn get_recent_transfer_tasks(
    configuration: &configuration::Configuration,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::TransferTaskListResponse, Error<GetRecentTransferTasksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_limit = limit;
    let p_query_offset = offset;

    let uri_str = format!("{}/v3/files/transfers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TransferTaskListResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TransferTaskListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRecentTransferTasksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve a transfer task. By default only the top level attributes are included in the result. The top level attributes are: tenantId, uuid, status, username, tag, created, startTime, endTime, errorMessage. The query parameter *includeSummary* may be set to *true* to also include totalTransfers, completeTransfers and estimatedTotalBytes. The default for *includeSummary* is *false*.  Certain services may use the query parameter *impersonationId* to be used in place of the requesting Tapis user. Tapis will use this user Id when performing authorization and resolving the *effectiveUserId* for the system.  TransferTask attributes:   - *tenantId*: tenant associated with the transfer task.   - *uuid*: Unique id of the transfer task.   - *tag*: Optional tag provided by user who requested the transfer.   - *username*: Tapis user who requested the transfer.    - *status*: ACCEPTED, STAGED, IN_PROGRESS, COMPLETED, CANCELLED, FAILED, FAILED_OPT, PAUSED   - *created*: Timestamp    - *startTime*: Timestamp   - *endTime*: Timestamp   - *errorMessage*: Error message, if applicable.   - *totalTransfers*: Total number of child transfers requested.   - *completeTransfers*: Number of child transfers completed.   - *estimatedTotalBytes*: Estimate of total number of bytes transferred by all child tasks.
pub async fn get_transfer_task(
    configuration: &configuration::Configuration,
    transfer_task_id: &str,
    include_summary: Option<bool>,
    impersonation_id: Option<&str>,
) -> Result<models::TransferTaskResponse, Error<GetTransferTaskError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_transfer_task_id = transfer_task_id;
    let p_query_include_summary = include_summary;
    let p_query_impersonation_id = impersonation_id;

    let uri_str = format!(
        "{}/v3/files/transfers/{transferTaskId}",
        configuration.base_path,
        transferTaskId = crate::apis::urlencode(p_path_transfer_task_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_include_summary {
        req_builder = req_builder.query(&[("includeSummary", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_impersonation_id {
        req_builder = req_builder.query(&[("impersonationId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TransferTaskResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TransferTaskResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTransferTaskError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve all information for a transfer task, including totalTransfers, completedTransfers, estimatedTotalBytes, list of parents and list of children for each parent.  Certain services may use the query parameter *impersonationId* to be used in place of the requesting Tapis user. Tapis will use this user Id when performing authorization and resolving the *effectiveUserId* for the system.  For more information on transfer task attributes please see *getTransferTask*.
pub async fn get_transfer_task_details(
    configuration: &configuration::Configuration,
    transfer_task_id: &str,
    impersonation_id: Option<&str>,
) -> Result<models::TransferTaskResponse, Error<GetTransferTaskDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_transfer_task_id = transfer_task_id;
    let p_query_impersonation_id = impersonation_id;

    let uri_str = format!(
        "{}/v3/files/transfers/{transferTaskId}/details",
        configuration.base_path,
        transferTaskId = crate::apis::urlencode(p_path_transfer_task_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_impersonation_id {
        req_builder = req_builder.query(&[("impersonationId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TransferTaskResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TransferTaskResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTransferTaskDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
