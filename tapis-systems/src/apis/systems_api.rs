/*
 * Tapis Systems API
 *
 * The Tapis Systems API provides for management of Tapis Systems including permissions, credentials and Scheduler Profiles.
 *
 * The version of the OpenAPI document: 25Q4.2
 * Contact: cicsupport@tacc.utexas.edu
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`change_system_owner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeSystemOwnerError {
    Status403(models::RespBasic),
    Status404(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_system`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSystemError {
    Status400(models::RespBasic),
    Status403(models::RespBasic),
    Status409(models::RespResourceUrl),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_system`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSystemError {
    Status403(models::RespBasic),
    Status404(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`disable_system`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DisableSystemError {
    Status403(models::RespBasic),
    Status404(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enable_system`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnableSystemError {
    Status403(models::RespBasic),
    Status404(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetHistoryError {
    Status403(models::RespBasic),
    Status404(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_system`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSystemError {
    Status400(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_systems`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSystemsError {
    Status400(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`host_eval`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HostEvalError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`is_enabled`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IsEnabledError {
    Status403(models::RespBasic),
    Status404(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`match_constraints`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MatchConstraintsError {
    Status400(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_system`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchSystemError {
    Status400(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_system`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutSystemError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status409(models::RespResourceUrl),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_systems_query_parameters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchSystemsQueryParametersError {
    Status400(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_systems_request_body`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchSystemsRequestBodyError {
    Status400(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`undelete_system`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UndeleteSystemError {
    Status403(models::RespBasic),
    Status404(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// Change owner of a system.  Please note that existing permission grants and shares will remain.  **WARNING** Note also that no credentials are deleted during this process. So, for example, after the change a system with a static *effectiveUserId* will retain the credentials and host access of the static *effectiveUser*.
pub async fn change_system_owner(
    configuration: &configuration::Configuration,
    system_id: &str,
    user_name: &str,
) -> Result<models::RespChangeCount, Error<ChangeSystemOwnerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;
    let p_path_user_name = user_name;

    let uri_str = format!(
        "{}/v3/systems/{systemId}/changeOwner/{userName}",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id),
        userName = crate::apis::urlencode(p_path_user_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespChangeCount`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespChangeCount`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeSystemOwnerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a system using a request body. System name must be unique within a tenant and can be composed of alphanumeric characters and the following special characters [-._~]. Name must begin with an alphanumeric character and can be no more than 80 characters in length. Description is optional with a maximum length of 2048 characters.  The attribute *host* represents a host name, IP address, Globus Endpoint Id or Globus Collection Id.  The attribute *effectiveUserId* determines the host login user, the user used to access the underlying host. The attribute can be set to a static string indicating a specific user (such as a service account) or dynamically specified as *${apiUserId}*. For the case of *${apiUserId}*, the service resolves the variable by extracting the identity from the request to the service (i.e. the JWT) and applying a mapping to a host login user if such a mapping has been provided. If no mapping is provided, then the extracted identity is taken to be the host login user.  If the *effectiveUserId* is static (i.e. not *${apiUserId}*) then credentials may optionally be provided in the *authnCredential* attribute of the request body. Please note that if there is a *loginUser* field in the credential request body, TAPIS will reject the request because the static effective user is always the login user. The Systems service does not store the secrets in its database, they are persisted in the Security Kernel.  By default for LINUX and S3 type systems credentials provided are verified. Use query parameter skipCredentialCheck=true to bypass initial verification of credentials.  The attribute *rootDir* serves as an effective root directory when operating on files through the Tapis Files service. All paths are relative to this directory when using Files to list, copy, move, mkdir, etc. Required for systems of type LINUX or IRODS. Supports the following variables which are resolved at create time: *${apiUserId}*, *${tenant}* and *${owner}*. May not be updated. Contact support to request a change.  There is also a special macro available for *rootDir* that may be used under certain conditions when a system is first created. The macro name is HOST_EVAL. The syntax for the macro is HOST_EVAL($var), where *var* is the environment variable to be evaluated on the system host when the create request is made. Note that the $ character preceding the environment variable name is optional. If after resolution the final path does not have the required leading slash (/) to make it an absolute path, then one will be prepended. The following conditions must be met in order to use the macro   - System must be of type LINUX   - Credentials must be provided when system is created.   - Macro HOST_EVAL() must only appear once and must be the first element of the path. Including a leading slash is optional.   - The *effectiveUserId* for the system must be static. Note that *effectiveUserId* may be set to *${owner}*.  Here are some examples    - HOST_EVAL($SCRATCH)   - HOST_EVAL($HOME)   - /HOST_EVAL(MY_ROOT_DIR)/scratch   - /HOST_EVAL($PROJECT_HOME)/projects/${tenant}/${owner}  Note that certain attributes in the request body (such as tenant) are allowed but ignored so that the JSON result returned by a GET may be modified and used when making a POST request to create a system. The attributes that are allowed but ignored are    - tenant   - uuid   - deleted   - created   - updated
pub async fn create_system(
    configuration: &configuration::Configuration,
    req_post_system: models::ReqPostSystem,
    skip_credential_check: Option<bool>,
) -> Result<models::RespResourceUrl, Error<CreateSystemError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_post_system = req_post_system;
    let p_query_skip_credential_check = skip_credential_check;

    let uri_str = format!("{}/v3/systems", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_skip_credential_check {
        req_builder = req_builder.query(&[("skipCredentialCheck", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_post_system);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespResourceUrl`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespResourceUrl`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSystemError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Mark a system as deleted. System will not appear in queries unless explicitly requested.
pub async fn delete_system(
    configuration: &configuration::Configuration,
    system_id: &str,
) -> Result<models::RespChangeCount, Error<DeleteSystemError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;

    let uri_str = format!(
        "{}/v3/systems/{systemId}/delete",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespChangeCount`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespChangeCount`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteSystemError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Mark a system unavailable for use.
pub async fn disable_system(
    configuration: &configuration::Configuration,
    system_id: &str,
) -> Result<models::RespChangeCount, Error<DisableSystemError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;

    let uri_str = format!(
        "{}/v3/systems/{systemId}/disable",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespChangeCount`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespChangeCount`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DisableSystemError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Mark a system available for use.
pub async fn enable_system(
    configuration: &configuration::Configuration,
    system_id: &str,
) -> Result<models::RespChangeCount, Error<EnableSystemError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;

    let uri_str = format!(
        "{}/v3/systems/{systemId}/enable",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespChangeCount`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespChangeCount`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnableSystemError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve history of changes for a given systemId.
pub async fn get_history(
    configuration: &configuration::Configuration,
    system_id: &str,
) -> Result<models::RespSystemHistory, Error<GetHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;

    let uri_str = format!(
        "{}/v3/systems/{systemId}/history",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespSystemHistory`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespSystemHistory`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve information for a system given the system Id.  Use query parameter *authnMethod* to override the default authentication method.  Certain Tapis services or a tenant administrator may use the query parameter *impersonationId* to be used in place of the requesting Tapis user. Tapis will use this user Id when performing authorization and resolving the *effectiveUserId*.  Certain Tapis services may use the query parameter *sharedAppCtx* to indicate that the request is in a shared application context.
pub async fn get_system(
    configuration: &configuration::Configuration,
    system_id: &str,
    authn_method: Option<&str>,
    require_exec_perm: Option<bool>,
    select: Option<&str>,
    return_credentials: Option<bool>,
    impersonation_id: Option<&str>,
    shared_app_ctx: Option<&str>,
    resource_tenant: Option<&str>,
) -> Result<models::RespSystem, Error<GetSystemError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;
    let p_query_authn_method = authn_method;
    let p_query_require_exec_perm = require_exec_perm;
    let p_query_select = select;
    let p_query_return_credentials = return_credentials;
    let p_query_impersonation_id = impersonation_id;
    let p_query_shared_app_ctx = shared_app_ctx;
    let p_query_resource_tenant = resource_tenant;

    let uri_str = format!(
        "{}/v3/systems/{systemId}",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_authn_method {
        req_builder = req_builder.query(&[("authnMethod", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_require_exec_perm {
        req_builder = req_builder.query(&[("requireExecPerm", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_select {
        req_builder = req_builder.query(&[("select", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_credentials {
        req_builder = req_builder.query(&[("returnCredentials", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_impersonation_id {
        req_builder = req_builder.query(&[("impersonationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_shared_app_ctx {
        req_builder = req_builder.query(&[("sharedAppCtx", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_resource_tenant {
        req_builder = req_builder.query(&[("resourceTenant", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespSystem`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespSystem`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSystemError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve list of systems.  Use *listType*, *search* and *select* query parameters to limit results. Query parameter *listType* allows for filtering results based on authorization. Please note that using *ALL* may have a significant negative impact on performance. Options for *listType* are    - *OWNED* Include only items owned by requester (Default).   - *SHARED_PUBLIC* Include only items shared publicly.   - *ALL* Include all items requester is authorized to view. Includes check for READ or MODIFY permission. May impact performance.  Use *hasCredentials* boolean query parameter to limit results based on the presence or absence of registered credentials for a system. Filtering is based on registered credentials for the current *defaultAuthnMethod* of a system. Credentials for other authentication method types are ignored. For a dynamic *effectiveUserId* filtering is based on the Tapis user making the request. If the query parameter is absent then no filtering is done.  Certain Tapis services or a tenant administrator may use the query parameter *impersonationId* to be used in place of the requesting Tapis user. Tapis will use this user Id when performing authorization and resolving the *effectiveUserId*.
pub async fn get_systems(
    configuration: &configuration::Configuration,
    search: Option<&str>,
    list_type: Option<models::ListTypeEnum>,
    limit: Option<i32>,
    order_by: Option<&str>,
    skip: Option<i32>,
    start_after: Option<&str>,
    compute_total: Option<bool>,
    select: Option<&str>,
    show_deleted: Option<bool>,
    impersonation_id: Option<&str>,
    has_credentials: Option<bool>,
) -> Result<models::RespSystems, Error<GetSystemsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_search = search;
    let p_query_list_type = list_type;
    let p_query_limit = limit;
    let p_query_order_by = order_by;
    let p_query_skip = skip;
    let p_query_start_after = start_after;
    let p_query_compute_total = compute_total;
    let p_query_select = select;
    let p_query_show_deleted = show_deleted;
    let p_query_impersonation_id = impersonation_id;
    let p_query_has_credentials = has_credentials;

    let uri_str = format!("{}/v3/systems", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_list_type {
        req_builder = req_builder.query(&[("listType", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_by {
        req_builder = req_builder.query(&[("orderBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_after {
        req_builder = req_builder.query(&[("startAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_compute_total {
        req_builder = req_builder.query(&[("computeTotal", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_select {
        req_builder = req_builder.query(&[("select", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_deleted {
        req_builder = req_builder.query(&[("showDeleted", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_impersonation_id {
        req_builder = req_builder.query(&[("impersonationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_has_credentials {
        req_builder = req_builder.query(&[("hasCredentials", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespSystems`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespSystems`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSystemsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Resolve environment variable by connecting to host associated with system. Note that this is done for the current *effectiveUserId*. Appropriate valid credentials must have already been registered. The system must be of type LINUX. The provided *{envVarName}* must start with an alphabetic character or underscore followed by 0 or more alphanumeric characters or underscores.
pub async fn host_eval(
    configuration: &configuration::Configuration,
    system_id: &str,
    env_var_name: &str,
) -> Result<models::RespName, Error<HostEvalError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;
    let p_path_env_var_name = env_var_name;

    let uri_str = format!(
        "{}/v3/systems/{systemId}/hostEval/{envVarName}",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id),
        envVarName = crate::apis::urlencode(p_path_env_var_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespName`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespName`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<HostEvalError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Check if a system is currently enabled, i.e. available for use.
pub async fn is_enabled(
    configuration: &configuration::Configuration,
    system_id: &str,
) -> Result<models::RespBoolean, Error<IsEnabledError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;

    let uri_str = format!(
        "{}/v3/systems/{systemId}/isEnabled",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespBoolean`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespBoolean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IsEnabledError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// **WARNING** *Capability constraint matching is not yet supported.*  Retrieve details for systems. Use request body to specify constraint conditions as an SQL-like WHERE clause.
pub async fn match_constraints(
    configuration: &configuration::Configuration,
    req_match_constraints: models::ReqMatchConstraints,
) -> Result<models::RespSystems, Error<MatchConstraintsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_match_constraints = req_match_constraints;

    let uri_str = format!("{}/v3/systems/match/constraints", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_match_constraints);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespSystems`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespSystems`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MatchConstraintsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update selected attributes of a system. Request body may only contain updatable attributes. System must exist.  Attributes that may not be updated via PATCH are    - id   - systemType   - owner   - enabled   - bucketName   - rootDir   - canExec  Note that the attributes owner and enabled may be modified using other endpoints.
pub async fn patch_system(
    configuration: &configuration::Configuration,
    system_id: &str,
    req_patch_system: models::ReqPatchSystem,
) -> Result<models::RespResourceUrl, Error<PatchSystemError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;
    let p_body_req_patch_system = req_patch_system;

    let uri_str = format!(
        "{}/v3/systems/{systemId}",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_patch_system);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespResourceUrl`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespResourceUrl`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchSystemError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update all updatable attributes of a system using a request body identical to POST. System must exist.  Note that certain attributes in the request body (such as tenant) are allowed but ignored so that the JSON result returned by a GET may be modified and used when making a PUT request to update a system.  The attributes that are allowed but ignored for both PUT and POST are   - tenant   - uuid   - deleted   - created   - updated  In addition for a PUT operation the following non-updatable attributes are allowed but ignored   - id   - systemType   - owner   - effectiveUserId   - authnCredential   - enabled   - bucketName   - rootDir   - canExec  Note that the attributes *owner*, *enabled* and *authnCredential* may be modified using other endpoints. Attribute *effectiveUserId* may be updated using the endpoint **patchSystem**.
pub async fn put_system(
    configuration: &configuration::Configuration,
    system_id: &str,
    req_put_system: models::ReqPutSystem,
    skip_credential_check: Option<bool>,
) -> Result<models::RespResourceUrl, Error<PutSystemError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;
    let p_body_req_put_system = req_put_system;
    let p_query_skip_credential_check = skip_credential_check;

    let uri_str = format!(
        "{}/v3/systems/{systemId}",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_skip_credential_check {
        req_builder = req_builder.query(&[("skipCredentialCheck", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_put_system);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespResourceUrl`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespResourceUrl`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutSystemError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve details for systems. Use query parameters to specify search conditions. For example owner.eq=jdoe&port.gt=1024 Use *listType* and *select* query parameters to limit results. Query parameter *listType* allows for filtering results based on authorization. Please note that using *ALL* may have a significant negative impact on performance. Options for *listType* are    - *OWNED* Include only items owned by requester (Default)   - *SHARED_PUBLIC* Include only items shared publicly   - *ALL* Include all items requester is authorized to view. Includes check for READ or MODIFY permission. May impact performance.  Use *hasCredentials* boolean query parameter to limit results based on the presence or absence of registered credentials for a system. Filtering is based on registered credentials for the current *defaultAuthnMethod* of a system. Credentials for other authentication method types are ignored. For a dynamic *effectiveUserId* filtering is based on the Tapis user making the request. If the query parameter is absent then no filtering is done.
pub async fn search_systems_query_parameters(
    configuration: &configuration::Configuration,
    free_form_parameter_name: Option<std::collections::HashMap<String, String>>,
    list_type: Option<models::ListTypeEnum>,
    limit: Option<i32>,
    order_by: Option<&str>,
    skip: Option<i32>,
    start_after: Option<&str>,
    compute_total: Option<bool>,
    select: Option<&str>,
    has_credentials: Option<bool>,
) -> Result<models::RespSystems, Error<SearchSystemsQueryParametersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_free_form_parameter_name = free_form_parameter_name;
    let p_query_list_type = list_type;
    let p_query_limit = limit;
    let p_query_order_by = order_by;
    let p_query_skip = skip;
    let p_query_start_after = start_after;
    let p_query_compute_total = compute_total;
    let p_query_select = select;
    let p_query_has_credentials = has_credentials;

    let uri_str = format!("{}/v3/systems/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_free_form_parameter_name {
        req_builder = req_builder.query(&[(
            "freeFormParameterName",
            &serde_json::to_string(param_value)?,
        )]);
    }
    if let Some(ref param_value) = p_query_list_type {
        req_builder = req_builder.query(&[("listType", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_by {
        req_builder = req_builder.query(&[("orderBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_after {
        req_builder = req_builder.query(&[("startAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_compute_total {
        req_builder = req_builder.query(&[("computeTotal", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_select {
        req_builder = req_builder.query(&[("select", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_has_credentials {
        req_builder = req_builder.query(&[("hasCredentials", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespSystems`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespSystems`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchSystemsQueryParametersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve details for systems. Use request body to specify SQL-like search conditions. Use *listType* and *select* query parameters to limit results. Query parameter *listType* allows for filtering results based on authorization. Please note that using *ALL* may have a significant negative impact on performance. Options for *listType* are    - *OWNED* Include only items owned by requester (Default)   - *SHARED_PUBLIC* Include only items shared publicly   - *ALL* Include all items requester is authorized to view. Includes check for READ or MODIFY permission. May impact performance.  Use *hasCredentials* boolean query parameter to limit results based on the presence or absence of registered credentials for a system. Filtering is based on registered credentials for the current *defaultAuthnMethod* of a system. Credentials for other authentication method types are ignored. For a dynamic *effectiveUserId* filtering is based on the Tapis user making the request. If the query parameter is absent then no filtering is done.
pub async fn search_systems_request_body(
    configuration: &configuration::Configuration,
    req_search_systems: models::ReqSearchSystems,
    list_type: Option<models::ListTypeEnum>,
    limit: Option<i32>,
    order_by: Option<&str>,
    skip: Option<i32>,
    start_after: Option<&str>,
    compute_total: Option<bool>,
    select: Option<&str>,
    has_credentials: Option<bool>,
) -> Result<models::RespSystems, Error<SearchSystemsRequestBodyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_search_systems = req_search_systems;
    let p_query_list_type = list_type;
    let p_query_limit = limit;
    let p_query_order_by = order_by;
    let p_query_skip = skip;
    let p_query_start_after = start_after;
    let p_query_compute_total = compute_total;
    let p_query_select = select;
    let p_query_has_credentials = has_credentials;

    let uri_str = format!("{}/v3/systems/search", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_list_type {
        req_builder = req_builder.query(&[("listType", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_by {
        req_builder = req_builder.query(&[("orderBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_after {
        req_builder = req_builder.query(&[("startAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_compute_total {
        req_builder = req_builder.query(&[("computeTotal", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_select {
        req_builder = req_builder.query(&[("select", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_has_credentials {
        req_builder = req_builder.query(&[("hasCredentials", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_search_systems);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespSystems`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespSystems`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchSystemsRequestBodyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Mark a system as not deleted. System will appear in queries.
pub async fn undelete_system(
    configuration: &configuration::Configuration,
    system_id: &str,
) -> Result<models::RespChangeCount, Error<UndeleteSystemError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_id = system_id;

    let uri_str = format!(
        "{}/v3/systems/{systemId}/undelete",
        configuration.base_path,
        systemId = crate::apis::urlencode(p_path_system_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespChangeCount`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespChangeCount`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UndeleteSystemError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
