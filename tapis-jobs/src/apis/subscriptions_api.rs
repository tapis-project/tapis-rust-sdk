/*
 * Tapis Jobs API
 *
 * The Tapis Jobs API executes jobs on Tapis systems.
 *
 * The version of the OpenAPI document: 25Q4.0
 * Contact: cicsupport@tacc.utexas.edu
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`delete_subscriptions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSubscriptionsError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_subscriptions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubscriptionsError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`subscribe`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubscribeError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}


/// Depending on the UUID provide, this API either deletes a single subscription from a job or all subscriptions from a job. To delete single subscription, provide the UUID of that subscription as listed in the subscription retrieval result for the job.  To delete all a job's subscriptions, specify the job UUID.  Like all Job subscription APIs, modifications only affect running jobs and never change the saved job definition. As a consequence, job resubmissions are not affected by runtime subscription changes.
pub async fn delete_subscriptions(configuration: &configuration::Configuration, uuid: &str) -> Result<models::ResultChangeCount, Error<DeleteSubscriptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!("{}/jobs/subscribe/{uuid}", configuration.base_path, uuid=crate::apis::urlencode(p_path_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ResultChangeCount`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ResultChangeCount`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteSubscriptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a job's subscriptions fom the Notifications service. After subscriptions expire or are deleted by user action they may no longer be listed in Notification service. To inspect the initial set of subscriptions assigned to a job, retrieve the job definition.
pub async fn get_subscriptions(configuration: &configuration::Configuration, job_uuid: &str, limit: Option<i32>, skip: Option<i32>) -> Result<models::RespGetSubscriptions, Error<GetSubscriptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_uuid = job_uuid;
    let p_query_limit = limit;
    let p_query_skip = skip;

    let uri_str = format!("{}/jobs/subscribe/{jobUuid}", configuration.base_path, jobUuid=crate::apis::urlencode(p_path_job_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespGetSubscriptions`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespGetSubscriptions`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubscriptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Subcribe to a running job identified by it's UUID. The caller must be the job owner or a tenant administrator.  Like all Job subscription APIs, modifications only affect running jobs and never change the saved job definition. As a consequence, job resubmissions are not affected by runtime subscription changes.  The events to which one can subscribe are:  - JOB_NEW_STATUS - the job has transitioned to a new status - JOB_INPUT_TRANSACTION_ID - a request to stage job input files has been submitted - JOB_ARCHIVE_TRANSACTION_ID - a request to archive job output files has been submitted - JOB_SUBSCRIPTION - a change to the job's subscriptions has occurred - JOB_SHARE_EVENT - a job resource has been shared or unshared - JOB_ERROR_MESSAGE - the job experienced an error - JOB_USER_EVENT - user generated events - ALL - all job event categories
pub async fn subscribe(configuration: &configuration::Configuration, job_uuid: &str, req_subscribe: models::ReqSubscribe) -> Result<models::RespResourceUrl, Error<SubscribeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_uuid = job_uuid;
    let p_body_req_subscribe = req_subscribe;

    let uri_str = format!("{}/jobs/subscribe/{jobUuid}", configuration.base_path, jobUuid=crate::apis::urlencode(p_path_job_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_subscribe);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespResourceUrl`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespResourceUrl`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SubscribeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

