/*
 * Tapis Jobs API
 *
 * The Tapis Jobs API executes jobs on Tapis systems.
 *
 * The version of the OpenAPI document: 25Q4.0
 * Contact: cicsupport@tacc.utexas.edu
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`cancel_job`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelJobError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespName),
    Status409(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_job`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJobError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_job_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJobHistoryError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_job_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJobListError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_job_output_download`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJobOutputDownloadError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_job_output_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJobOutputListError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_job_search_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJobSearchListError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_job_search_list_by_post_sql_str`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJobSearchListByPostSqlStrError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_job_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJobStatusError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_resubmit_request_json`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetResubmitRequestJsonError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`hide_job`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HideJobError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespName),
    Status409(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_job_annotations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchJobAnnotationsError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespName),
    Status409(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_job_annotations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutJobAnnotationsError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespName),
    Status409(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`resubmit_job`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResubmitJobError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendEventError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`submit_job`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubmitJobError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unhide_job`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnhideJobError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status403(models::RespBasic),
    Status404(models::RespName),
    Status409(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}


/// Cancel a previously submitted job by its UUID.  The caller must be the job owner, creator or a tenant administrator.
pub async fn cancel_job(configuration: &configuration::Configuration, job_uuid: &str, body: Option<serde_json::Value>) -> Result<models::RespCancelJob, Error<CancelJobError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_uuid = job_uuid;
    let p_body_body = body;

    let uri_str = format!("{}/jobs/{jobUuid}/cancel", configuration.base_path, jobUuid=crate::apis::urlencode(p_path_job_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespCancelJob`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespCancelJob`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelJobError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a previously submitted job by its UUID.  The caller must be the job owner, creator or a tenant administrator.
pub async fn get_job(configuration: &configuration::Configuration, job_uuid: &str) -> Result<models::RespGetJob, Error<GetJobError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_uuid = job_uuid;

    let uri_str = format!("{}/jobs/{jobUuid}", configuration.base_path, jobUuid=crate::apis::urlencode(p_path_job_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespGetJob`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespGetJob`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetJobError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve history of a previously submitted job by its UUID.  The caller must be the job owner, creator or a tenant administrator.
pub async fn get_job_history(configuration: &configuration::Configuration, job_uuid: &str, limit: Option<i32>, skip: Option<i32>) -> Result<models::RespJobHistory, Error<GetJobHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_uuid = job_uuid;
    let p_query_limit = limit;
    let p_query_skip = skip;

    let uri_str = format!("{}/jobs/{jobUuid}/history", configuration.base_path, jobUuid=crate::apis::urlencode(p_path_job_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespJobHistory`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespJobHistory`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetJobHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve list of jobs for which the user is the job owner, creator or a tenant administrator.  Also list the jobs that are shared with the user.  listType allowed are: MY_JOBS, SHARED_JOBS, ALL_JOBS
pub async fn get_job_list(configuration: &configuration::Configuration, limit: Option<i32>, skip: Option<i32>, start_after: Option<i32>, order_by: Option<&str>, compute_total: Option<bool>, list_type: Option<&str>) -> Result<models::RespGetJobList, Error<GetJobListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_limit = limit;
    let p_query_skip = skip;
    let p_query_start_after = start_after;
    let p_query_order_by = order_by;
    let p_query_compute_total = compute_total;
    let p_query_list_type = list_type;

    let uri_str = format!("{}/jobs/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_after {
        req_builder = req_builder.query(&[("startAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_by {
        req_builder = req_builder.query(&[("orderBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_compute_total {
        req_builder = req_builder.query(&[("computeTotal", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_list_type {
        req_builder = req_builder.query(&[("listType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespGetJobList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespGetJobList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetJobListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Download a job's output files using the job's UUID. By default, the job must be in a terminal state (FINISHED or FAILED or CANCELLED) for this command to execute. To execute when a job is not in a terminal state--and possibly receive incomplete results--set _allowIfRunning=true_.    The caller must be the job owner, creator or a tenant administrator. The _outputPath_ is always relative to the job output directory and must end with a '/'.
pub async fn get_job_output_download(configuration: &configuration::Configuration, job_uuid: &str, output_path: &str, compress: Option<bool>, format: Option<&str>, allow_if_running: Option<bool>) -> Result<reqwest::Response, Error<GetJobOutputDownloadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_uuid = job_uuid;
    let p_path_output_path = output_path;
    let p_query_compress = compress;
    let p_query_format = format;
    let p_query_allow_if_running = allow_if_running;

    let uri_str = format!("{}/jobs/{jobUuid}/output/download/{outputPath}", configuration.base_path, jobUuid=crate::apis::urlencode(p_path_job_uuid), outputPath=crate::apis::urlencode(p_path_output_path));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_compress {
        req_builder = req_builder.query(&[("compress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_allow_if_running {
        req_builder = req_builder.query(&[("allowIfRunning", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetJobOutputDownloadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a job's output file listing using the job's UUID. By default, the job must be in a terminal state (FINISHED or FAILED or CANCELLED) for this command to execute. To execute when a job is not in a terminal state--and possibly receive incomplete results--set _allowIfRunning=true_.    The caller must be the job owner, creator or a tenant administrator. The _outputPath_ is always relative to the job output directory and must end with a '/'.
pub async fn get_job_output_list(configuration: &configuration::Configuration, job_uuid: &str, output_path: &str, limit: Option<i32>, skip: Option<i32>, allow_if_running: Option<bool>) -> Result<models::RespGetJobOutputList, Error<GetJobOutputListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_uuid = job_uuid;
    let p_path_output_path = output_path;
    let p_query_limit = limit;
    let p_query_skip = skip;
    let p_query_allow_if_running = allow_if_running;

    let uri_str = format!("{}/jobs/{jobUuid}/output/list/{outputPath}", configuration.base_path, jobUuid=crate::apis::urlencode(p_path_job_uuid), outputPath=crate::apis::urlencode(p_path_output_path));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_allow_if_running {
        req_builder = req_builder.query(&[("allowIfRunning", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespGetJobOutputList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespGetJobOutputList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetJobOutputListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve list of jobs for the user based on search conditions in the query paramter on the dedicated search end-point.  The caller must be the job owner, creator or a tenant administrator.   List of Jobs shared with the user can also be searched
pub async fn get_job_search_list(configuration: &configuration::Configuration, limit: Option<i32>, skip: Option<i32>, start_after: Option<i32>, order_by: Option<&str>, compute_total: Option<bool>, select: Option<&str>, list_type: Option<&str>) -> Result<models::RespJobSearchAllAttributes, Error<GetJobSearchListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_limit = limit;
    let p_query_skip = skip;
    let p_query_start_after = start_after;
    let p_query_order_by = order_by;
    let p_query_compute_total = compute_total;
    let p_query_select = select;
    let p_query_list_type = list_type;

    let uri_str = format!("{}/jobs/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_after {
        req_builder = req_builder.query(&[("startAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_by {
        req_builder = req_builder.query(&[("orderBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_compute_total {
        req_builder = req_builder.query(&[("computeTotal", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_select {
        req_builder = req_builder.query(&[("select", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_list_type {
        req_builder = req_builder.query(&[("listType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespJobSearchAllAttributes`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespJobSearchAllAttributes`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetJobSearchListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve list of jobs for the user based on search conditions in the request body and pagination information from the query paramter on the dedicated search end-point.  The caller must be the job owner, creator or a tenant administrator.
pub async fn get_job_search_list_by_post_sql_str(configuration: &configuration::Configuration, limit: Option<i32>, skip: Option<i32>, start_after: Option<i32>, order_by: Option<&str>, compute_total: Option<bool>, select: Option<&str>, list_type: Option<&str>, body: Option<serde_json::Value>) -> Result<models::RespJobSearchAllAttributes, Error<GetJobSearchListByPostSqlStrError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_limit = limit;
    let p_query_skip = skip;
    let p_query_start_after = start_after;
    let p_query_order_by = order_by;
    let p_query_compute_total = compute_total;
    let p_query_select = select;
    let p_query_list_type = list_type;
    let p_body_body = body;

    let uri_str = format!("{}/jobs/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_after {
        req_builder = req_builder.query(&[("startAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_by {
        req_builder = req_builder.query(&[("orderBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_compute_total {
        req_builder = req_builder.query(&[("computeTotal", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_select {
        req_builder = req_builder.query(&[("select", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_list_type {
        req_builder = req_builder.query(&[("listType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespJobSearchAllAttributes`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespJobSearchAllAttributes`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetJobSearchListByPostSqlStrError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve status of a previously submitted job by its UUID.  The caller must be the job owner, creator or a tenant administrator.
pub async fn get_job_status(configuration: &configuration::Configuration, job_uuid: &str) -> Result<models::RespGetJobStatus, Error<GetJobStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_uuid = job_uuid;

    let uri_str = format!("{}/jobs/{jobUuid}/status", configuration.base_path, jobUuid=crate::apis::urlencode(p_path_job_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespGetJobStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespGetJobStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetJobStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Resubmit request for of a job in JSON format.  
pub async fn get_resubmit_request_json(configuration: &configuration::Configuration, job_uuid: &str) -> Result<models::RespGetResubmit, Error<GetResubmitRequestJsonError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_uuid = job_uuid;

    let uri_str = format!("{}/jobs/{jobUuid}/resubmit_request", configuration.base_path, jobUuid=crate::apis::urlencode(p_path_job_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespGetResubmit`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespGetResubmit`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetResubmitRequestJsonError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Hide a job by its UUID.  The caller must be the job owner, creator or a tenant administrator.
pub async fn hide_job(configuration: &configuration::Configuration, job_uuid: &str, body: Option<serde_json::Value>) -> Result<models::RespHideJob, Error<HideJobError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_uuid = job_uuid;
    let p_body_body = body;

    let uri_str = format!("{}/jobs/{jobUuid}/hide", configuration.base_path, jobUuid=crate::apis::urlencode(p_path_job_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespHideJob`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespHideJob`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<HideJobError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adding tags or notes with the following behavior: ## Behavior   - **Tags**: Repetitive tags will be ignored (case-sensitive merging)   - **Notes**: Old notes will be updated with new values if the key is the same   - If any of the tags/notes field is missing in the request body, the corresponding field in jobs will not be touched.  ## Limits   - Total number of bytes of tags/notes: **128KB maximum**.    - Depending on the byte-length of the characters, tags and notes can have 32768 (4-byte) - 131072 (ASCII) UTF-8 characters.   - Overall, there is no guarantee of success if tags/notes exceed 32768 UTF-8 characters.  ## Authorization    - Caller must be the job owner, creator, or tenant administrator  **Note**: This operation merges new data with existing annotations rather than replacing them.
pub async fn patch_job_annotations(configuration: &configuration::Configuration, job_uuid: &str, req_job_annotation: models::ReqJobAnnotation) -> Result<models::RespJobAnnotations, Error<PatchJobAnnotationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_uuid = job_uuid;
    let p_body_req_job_annotation = req_job_annotation;

    let uri_str = format!("{}/jobs/{jobUuid}/annotations", configuration.base_path, jobUuid=crate::apis::urlencode(p_path_job_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_job_annotation);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespJobAnnotations`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespJobAnnotations`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchJobAnnotationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Replace tags or notes with the provided values.  ## Behavior   - **Tags**: Completely replaces existing tags with the provided array   - **Notes**: Completely replaces existing notes with the provided JSON object   - **Clearing Data**:      - Provide empty array `[]` for tags to remove all tags     - Provide empty object `{}` for notes to remove all notes   - If any of the tags/notes field is missing in the request body, the corresponding field in jobs will not be touched.  ## Limits   - Total number of bytes of tags/notes: **128KB maximum**.    - Depending on the byte-length of the characters, tags and notes can have 32768 (4-byte) - 131072 (ASCII) UTF-8 characters.   - Overall, there is no guarantee of success if tags/notes exceed 32768 UTF-8 characters.  ## Authorization   - The caller must be the job owner, creator, or a tenant administrator.  **Note**: This operation completely replaces existing annotations rather than merging them.
pub async fn put_job_annotations(configuration: &configuration::Configuration, job_uuid: &str, req_job_annotation: models::ReqJobAnnotation) -> Result<models::RespJobAnnotations, Error<PutJobAnnotationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_uuid = job_uuid;
    let p_body_req_job_annotation = req_job_annotation;

    let uri_str = format!("{}/jobs/{jobUuid}/annotations", configuration.base_path, jobUuid=crate::apis::urlencode(p_path_job_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_job_annotation);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespJobAnnotations`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespJobAnnotations`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutJobAnnotationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Resubmit a job for execution using the job's original parameters.  The main phases of job execution are:    - validate input   - check resource availability   - stage input files   - stage application code   - launch application   - monitor application   - archive application output  When a job is submitted its request payload is captured and available for resubmission using this API. The resubmitted job is assigned a new UUID and does not reference or have any special access to the original job's information once the orginal job's request is copied. The resubmitted job's execution can differ from the original job's if the application, system or other aspects of the execution environment have changed.
pub async fn resubmit_job(configuration: &configuration::Configuration, job_uuid: &str, body: Option<serde_json::Value>) -> Result<models::RespSubmitJob, Error<ResubmitJobError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_uuid = job_uuid;
    let p_body_body = body;

    let uri_str = format!("{}/jobs/{jobUuid}/resubmit", configuration.base_path, jobUuid=crate::apis::urlencode(p_path_job_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespSubmitJob`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespSubmitJob`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResubmitJobError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send a user event to an active job. The job must be in the same tenant as the caller, but no other authorization is needed. If the job has terminated the request will be rejected. The caller must specify a payload of non-empty string data in the *eventData* field. The *eventDetail* field can be set to further qualify the type of user event, which is useful when filtering events. If not provided the *eventDetail* defaults to \"DEFAULT\".  Subscribers that register interest in events of type JOB_USER_EVENT will receive a notification as a result of this call.
pub async fn send_event(configuration: &configuration::Configuration, job_uuid: &str, req_user_event: models::ReqUserEvent) -> Result<models::RespBasic, Error<SendEventError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_uuid = job_uuid;
    let p_body_req_user_event = req_user_event;

    let uri_str = format!("{}/jobs/{jobUuid}/sendEvent", configuration.base_path, jobUuid=crate::apis::urlencode(p_path_job_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_user_event);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespBasic`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespBasic`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SendEventError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submit a job for execution.  The main phases of job execution are:    - validate input   - check resource availability   - stage input files   - stage application code   - launch application   - monitor application   - archive application output  At a minimum, the job name, application ID and application version must be specified in the request payload. The optional parameters available in a job request provide great flexibility but must be considered in the context of the application and system definitions. The actual values used during job execution are a combination of the values in this request and those specified in the job's application and system definitions. It's often desirable to keep the submission request simple by specifying common values in these other two definitions. See the [Job Submission Request](https://tapis.readthedocs.io/en/latest/technical/jobs.html#the-job-submission-request) documentation for details. The total number of tags of a job is limited to be 128 and the total size of tags/notes is limited to be 128K bytes.
pub async fn submit_job(configuration: &configuration::Configuration, req_submit_job: models::ReqSubmitJob) -> Result<models::RespSubmitJob, Error<SubmitJobError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_submit_job = req_submit_job;

    let uri_str = format!("{}/jobs/submit", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_submit_job);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespSubmitJob`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespSubmitJob`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SubmitJobError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Un-hide a job by its UUID.  The caller must be the job owner, creator or a tenant administrator.
pub async fn unhide_job(configuration: &configuration::Configuration, job_uuid: &str, body: Option<serde_json::Value>) -> Result<models::RespHideJob, Error<UnhideJobError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_uuid = job_uuid;
    let p_body_body = body;

    let uri_str = format!("{}/jobs/{jobUuid}/unhide", configuration.base_path, jobUuid=crate::apis::urlencode(p_path_job_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespHideJob`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespHideJob`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UnhideJobError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

