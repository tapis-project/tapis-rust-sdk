/*
 * Tapis Security API
 *
 * The Tapis Security API provides for management of Security Kernel (SK) role-based authorization and secrets resources. 
 *
 * The version of the OpenAPI document: 1.8.2
 * Contact: cicsupport@tacc.utexas.edu
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`reinitialize_site`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReinitializeSiteError {
    Status503(models::RespBasic),
    UnknownValue(serde_json::Value),
}


/// Request to reinitialize tenants for the site.  This should be called if tenants are added to the site.  When called any site initialization will be run again.  At present this is mainly just asking for a fresh list of the tenants from the tenant service, and reprocessing each tenant (this might include role creation or assignment for tenant admins).  There is code that prevents running this \"too frequently\".  The current default value is 10 minutes, meaning that if you make this request and try to do it again before 10 minutes elapses, the request is ignored.  Only site admins can make this request. 
pub async fn reinitialize_site(configuration: &configuration::Configuration, ) -> Result<models::RespAuthorized, Error<ReinitializeSiteError>> {

    let uri_str = format!("{}/security/admin/reinitialize", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespAuthorized`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespAuthorized`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReinitializeSiteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

