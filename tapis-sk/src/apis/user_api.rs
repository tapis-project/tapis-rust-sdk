/*
 * Tapis Security API
 *
 * The Tapis Security API provides for management of Security Kernel (SK) role-based authorization and secrets resources.
 *
 * The version of the OpenAPI document: 1.8.2
 * Contact: cicsupport@tacc.utexas.edu
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`get_admins`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAdminsError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status404(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_default_user_role1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDefaultUserRole1Error {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserNamesError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_perms`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserPermsError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_roles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserRolesError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_users_with_permission`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUsersWithPermissionError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_users_with_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUsersWithRoleError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status404(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`grant_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GrantRoleError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status404(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`grant_role_with_permission`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GrantRoleWithPermissionError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status404(models::RespName),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`grant_user_permission`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GrantUserPermissionError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`has_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HasRoleError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`has_role_all`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HasRoleAllError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`has_role_any`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HasRoleAnyError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`is_admin`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IsAdminError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`is_permitted`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IsPermittedError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`is_permitted_all`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IsPermittedAllError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`is_permitted_any`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IsPermittedAnyError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeRoleError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_user_permission`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeUserPermissionError {
    Status400(models::RespBasic),
    Status401(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// Get all users assigned the tenant administrator role ($!tenant_admin).  This request is authorized if the requestor is a service or a user that has access to the specified tenant.
pub async fn get_admins(
    configuration: &configuration::Configuration,
    tenant: &str,
) -> Result<models::RespNameArray, Error<GetAdminsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_tenant = tenant;

    let uri_str = format!(
        "{}/security/user/admins/{tenant}",
        configuration.base_path,
        tenant = crate::apis::urlencode(p_path_tenant)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespNameArray`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespNameArray`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAdminsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a user's default role. The default role is implicitly created by the system when needed if it doesn't already exist. No authorization required.  A user's default role is constructed by prepending '$$' to the user's name. This implies the maximum length of a user name is 58 since role names are limited to 60 characters.
pub async fn get_default_user_role1(
    configuration: &configuration::Configuration,
    user: &str,
) -> Result<models::RespName, Error<GetDefaultUserRole1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user = user;

    let uri_str = format!(
        "{}/security/user/defaultRole/{user}",
        configuration.base_path,
        user = crate::apis::urlencode(p_path_user)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespName`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespName`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDefaultUserRole1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the names of all users in the tenant that have been granted a role or permission.  This request is authorized if the requestor is a service or a user that has access to the specified tenant.
pub async fn get_user_names(
    configuration: &configuration::Configuration,
    tenant: Option<&str>,
) -> Result<models::RespNameArray, Error<GetUserNamesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_tenant = tenant;

    let uri_str = format!("{}/security/user", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_tenant {
        req_builder = req_builder.query(&[("tenant", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespNameArray`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespNameArray`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserNamesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the permissions assigned to a user in a tenant, including those assigned transively. The result list can be optionally filtered by the one or both of the query parameters: implies and impliedBy.  When implies is set, the filter _implies_ each entry in the result set. When impliedBy is set, each entry in the result set is _implied by_ the filter. Below are some examples.  Consider a user that is assigned these permissions:      stream:dev:read:project1     stream:dev:read,write:project1     stream:dev:read,write,exec:project1  **Using the *implies* Query Parameter**  When _implies=stream:dev:*:project1_, this endpoint returns:      stream:dev:read:project1     stream:dev:read,write:project1     stream:dev:read,write,exec:project1  When _implies=stream:dev:write:project1_, this endpoint returns an empty list.  **Using the *impliedBy* Query Parameter**  When _impliedBy=stream:dev:*:project1_, this endpoint returns an empty list.  When _impliedBy=stream:dev:write:project1_, this endpoint returns:      stream:dev:read,write:project1     stream:dev:read,write,exec:project1  This request is authorized if the requestor is a service or a user that has access to the specified tenant.
pub async fn get_user_perms(
    configuration: &configuration::Configuration,
    user: &str,
    tenant: Option<&str>,
    implies: Option<&str>,
    implied_by: Option<&str>,
) -> Result<models::RespNameArray, Error<GetUserPermsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user = user;
    let p_query_tenant = tenant;
    let p_query_implies = implies;
    let p_query_implied_by = implied_by;

    let uri_str = format!(
        "{}/security/user/perms/{user}",
        configuration.base_path,
        user = crate::apis::urlencode(p_path_user)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_tenant {
        req_builder = req_builder.query(&[("tenant", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_implies {
        req_builder = req_builder.query(&[("implies", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_implied_by {
        req_builder = req_builder.query(&[("impliedBy", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespNameArray`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespNameArray`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserPermsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the roles assigned to a user in the specified tenant, including those assigned transively.  This request is authorized if the requestor is a service or a user that has access to the specified tenant.
pub async fn get_user_roles(
    configuration: &configuration::Configuration,
    user: &str,
    tenant: Option<&str>,
) -> Result<models::RespNameArray, Error<GetUserRolesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user = user;
    let p_query_tenant = tenant;

    let uri_str = format!(
        "{}/security/user/roles/{user}",
        configuration.base_path,
        user = crate::apis::urlencode(p_path_user)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_tenant {
        req_builder = req_builder.query(&[("tenant", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespNameArray`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespNameArray`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserRolesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all users in a tenant assigned a permission. The permSpec parameter is a permission specification that uses colons as separators, the asterisk as a wildcard character and commas to define lists. Here are examples of permission specifications:      system:mytenant:read:mysystem     system:mytenant:*:mysystem     system:mytenant     files:mytenant:read,write:mysystems This method recognizes the percent sign (%) as a string wildcard only in the context of database searching. If a percent sign (%) appears in the permSpec it is interpreted as a zero or more character wildcard. For example, the following specification would match the first three of the above example specifications but not the fourth:      system:mytenant:%  The wildcard character cannot appear as the first character in the permSpec.  This request is authorized if the requestor is a service or a user that has access to the specified tenant.
pub async fn get_users_with_permission(
    configuration: &configuration::Configuration,
    perm_spec: &str,
    tenant: Option<&str>,
) -> Result<models::RespNameArray, Error<GetUsersWithPermissionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_perm_spec = perm_spec;
    let p_query_tenant = tenant;

    let uri_str = format!(
        "{}/security/user/withPermission/{permSpec}",
        configuration.base_path,
        permSpec = crate::apis::urlencode(p_path_perm_spec)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_tenant {
        req_builder = req_builder.query(&[("tenant", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespNameArray`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespNameArray`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUsersWithPermissionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all users assigned a role. The role must exist in the tenant.  This request is authorized if the requestor is a service or a user that has access to the specified tenant.
pub async fn get_users_with_role(
    configuration: &configuration::Configuration,
    role_name: &str,
    tenant: Option<&str>,
    role_type: Option<models::RoleTypeEnum>,
) -> Result<models::RespNameArray, Error<GetUsersWithRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_role_name = role_name;
    let p_query_tenant = tenant;
    let p_query_role_type = role_type;

    let uri_str = format!(
        "{}/security/user/withRole/{roleName}",
        configuration.base_path,
        roleName = crate::apis::urlencode(p_path_role_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_tenant {
        req_builder = req_builder.query(&[("tenant", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_role_type {
        req_builder = req_builder.query(&[("roleType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespNameArray`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespNameArray`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUsersWithRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Grant a user the specified role. A valid tenant and user must be specified in the request body. The type of role to grant may be specified in the request body. Allowed types are USER, TENANT_ADMIN and RESTRICTED_SVC. Default type is USER.  The user and the role must be in the same tenant.  For roles of type USER the request is authorized only if the requestor is the role owner, a tenant administrator or a site administrator. For roles of type TENANT_ADMIN the requestor must a tenant or site administrator. For roles of type RESTRICTED_SVC the requestor must a site administrator.
pub async fn grant_role(
    configuration: &configuration::Configuration,
    req_grant_role: models::ReqGrantRole,
) -> Result<models::RespChangeCount, Error<GrantRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_grant_role = req_grant_role;

    let uri_str = format!("{}/security/user/grantRole", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_grant_role);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespChangeCount`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespChangeCount`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GrantRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Grant a user the specified role containing the specified permission. This compound request first adds the permission to the role if it is not already a member of the role and then assigns the role to the user. The change count returned can range from zero to two depending on how many insertions were actually required.  The user and the role must be in the same tenant.  For roles of type USER the request is authorized only if the requestor is the role owner, a tenant administrator or a site administrator. For roles of type TENANT_ADMIN the requestor must a tenant or site administrator. For roles of type RESTRICTED_SVC the requestor must a site administrator.
pub async fn grant_role_with_permission(
    configuration: &configuration::Configuration,
    req_grant_role_with_permission: models::ReqGrantRoleWithPermission,
) -> Result<models::RespChangeCount, Error<GrantRoleWithPermissionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_grant_role_with_permission = req_grant_role_with_permission;

    let uri_str = format!(
        "{}/security/user/grantRoleWithPerm",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_grant_role_with_permission);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespChangeCount`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespChangeCount`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GrantRoleWithPermissionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Grant a user the specified permission by assigning that permission to to the user's default role. If the user's default role does not exist it will be created.  A user's default role name is discoverable by calling either of the user/defaultRole or role/defaultRole endpoints.  The change count returned can range from zero to three depending on how many insertions and updates were actually required.  The caller must be an administrator or service allowed to perform updates in the user's tenant.
pub async fn grant_user_permission(
    configuration: &configuration::Configuration,
    req_grant_user_permission: models::ReqGrantUserPermission,
) -> Result<models::RespChangeCount, Error<GrantUserPermissionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_grant_user_permission = req_grant_user_permission;

    let uri_str = format!(
        "{}/security/user/grantUserPermission",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_grant_user_permission);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespChangeCount`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespChangeCount`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GrantUserPermissionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Check whether a user in a tenant has been assigned the specified role, either directly or transitively.  This request is authorized if the requestor is a service or a user that has access to the specified tenant.
pub async fn has_role(
    configuration: &configuration::Configuration,
    req_user_has_role: models::ReqUserHasRole,
) -> Result<models::RespAuthorized, Error<HasRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_user_has_role = req_user_has_role;

    let uri_str = format!("{}/security/user/hasRole", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_user_has_role);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespAuthorized`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespAuthorized`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<HasRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Check whether a user in a tenant has been assigned all of the roles specified in the request body.  This request is authorized if the requestor is a service or a user that has access to the specified tenant.
pub async fn has_role_all(
    configuration: &configuration::Configuration,
    req_user_has_role_multi: models::ReqUserHasRoleMulti,
) -> Result<models::RespAuthorized, Error<HasRoleAllError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_user_has_role_multi = req_user_has_role_multi;

    let uri_str = format!("{}/security/user/hasRoleAll", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_user_has_role_multi);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespAuthorized`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespAuthorized`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<HasRoleAllError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Check whether a user in a tenant has been assigned any of the roles specified in the request body.  This request is authorized if the requestor is a service or a user that has access to the specified tenant.
pub async fn has_role_any(
    configuration: &configuration::Configuration,
    req_user_has_role_multi: models::ReqUserHasRoleMulti,
) -> Result<models::RespAuthorized, Error<HasRoleAnyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_user_has_role_multi = req_user_has_role_multi;

    let uri_str = format!("{}/security/user/hasRoleAny", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_user_has_role_multi);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespAuthorized`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespAuthorized`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<HasRoleAnyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Check whether a user in a tenant has been assigned the tenant administrator role, either directly or transitively.  This request is authorized if the requestor is a service or a user that has access to the specified tenant.
pub async fn is_admin(
    configuration: &configuration::Configuration,
    req_user_is_admin: models::ReqUserIsAdmin,
) -> Result<models::RespAuthorized, Error<IsAdminError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_user_is_admin = req_user_is_admin;

    let uri_str = format!("{}/security/user/isAdmin", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_user_is_admin);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespAuthorized`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespAuthorized`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IsAdminError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Check whether specified permission matches a permission assigned to the user, either directly or transitively.  This request is authorized if the requestor is a service or a user that has access to the specified tenant.
pub async fn is_permitted(
    configuration: &configuration::Configuration,
    req_user_is_permitted: models::ReqUserIsPermitted,
) -> Result<models::RespAuthorized, Error<IsPermittedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_user_is_permitted = req_user_is_permitted;

    let uri_str = format!("{}/security/user/isPermitted", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_user_is_permitted);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespAuthorized`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespAuthorized`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IsPermittedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Check whether a user's permissions satisfy all of the permission specifications contained in the request body.  This request is authorized if the requestor is a service or a user that has access to the specified tenant.
pub async fn is_permitted_all(
    configuration: &configuration::Configuration,
    req_user_is_permitted_multi: models::ReqUserIsPermittedMulti,
) -> Result<models::RespAuthorized, Error<IsPermittedAllError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_user_is_permitted_multi = req_user_is_permitted_multi;

    let uri_str = format!("{}/security/user/isPermittedAll", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_user_is_permitted_multi);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespAuthorized`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespAuthorized`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IsPermittedAllError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Check whether a user's permissions satisfy any of the permission specifications contained in the request body.  This request is authorized if the requestor is a service or a user that has access to the specified tenant.
pub async fn is_permitted_any(
    configuration: &configuration::Configuration,
    req_user_is_permitted_multi: models::ReqUserIsPermittedMulti,
) -> Result<models::RespAuthorized, Error<IsPermittedAnyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_user_is_permitted_multi = req_user_is_permitted_multi;

    let uri_str = format!("{}/security/user/isPermittedAny", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_user_is_permitted_multi);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespAuthorized`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespAuthorized`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IsPermittedAnyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Revoke a previously granted role from a user. No action is taken if the user is not currently assigned the role. This request is idempotent.  The type of role to grant may be specified in the request body. Allowed types are USER, TENANT_ADMIN and RESTRICTED_SVC. Default type is USER.  The user and the role must be in the same tenant.  For roles of type USER the request is authorized only if the requestor is the role owner, a tenant administrator or a site administrator. For roles of type TENANT_ADMIN the requestor must a tenant or site administrator. For roles of type RESTRICTED_SVC the requestor must a site administrator.
pub async fn revoke_role(
    configuration: &configuration::Configuration,
    req_revoke_role: models::ReqRevokeRole,
) -> Result<models::RespChangeCount, Error<RevokeRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_revoke_role = req_revoke_role;

    let uri_str = format!("{}/security/user/revokeRole", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_revoke_role);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespChangeCount`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespChangeCount`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RevokeRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Revoke the specified permission from the user's default role. A user's default role is constructed by prepending '$$' to the user's name. Default roles are created on demand. If the role does not exist when this method is called no error is reported and no changes occur.  The change count returned can be zero or one depending on how many permissions were revoked.  A valid tenant and user must be specified in the request body. The caller must be an administrator, a service or the user themselves.
pub async fn revoke_user_permission(
    configuration: &configuration::Configuration,
    req_revoke_user_permission: models::ReqRevokeUserPermission,
) -> Result<models::RespChangeCount, Error<RevokeUserPermissionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_req_revoke_user_permission = req_revoke_user_permission;

    let uri_str = format!(
        "{}/security/user/revokeUserPermission",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Tapis-Token", value);
    };
    req_builder = req_builder.json(&p_body_req_revoke_user_permission);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespChangeCount`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespChangeCount`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RevokeUserPermissionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
