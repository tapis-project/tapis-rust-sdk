/*
 * Tapis Globus Proxy API
 *
 * The Tapis Globus Proxy API proxies calls to Globus coming from a Tapis service.
 *
 * The version of the OpenAPI document: 1.3.0
 * Contact: cicsupport@tacc.utexas.edu
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`cancel_transfer_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelTransferTaskError {
    Status401(models::RespBasic),
    Status407(models::RespEndpointArray),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_transfer_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTransferTaskError {
    Status401(models::RespBasic),
    Status407(models::RespEndpointArray),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transfer_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransferTaskError {
    Status401(models::RespBasic),
    Status407(models::RespEndpointArray),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// Request that a transfer task be cancelled. Note that even if the response indicates that the task has been cancelled the task still may have succeeded. Task status must be checked. See Globus documentation.
pub async fn cancel_transfer_task(
    configuration: &configuration::Configuration,
    client_id: &str,
    task_id: &str,
    access_token: &str,
    refresh_token: &str,
) -> Result<models::RespCancelTask, Error<CancelTransferTaskError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_client_id = client_id;
    let p_path_task_id = task_id;
    let p_query_access_token = access_token;
    let p_query_refresh_token = refresh_token;

    let uri_str = format!(
        "{}/v3/globus-proxy/transfers/{client_id}/{task_id}",
        configuration.base_path,
        client_id = crate::apis::urlencode(p_path_client_id),
        task_id = crate::apis::urlencode(p_path_task_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("access_token", &p_query_access_token.to_string())]);
    req_builder = req_builder.query(&[("refresh_token", &p_query_refresh_token.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespCancelTask`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespCancelTask`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelTransferTaskError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a task to transfer files from a source endpoint to a destination endpoint. File paths are relative to the endpoint default directories. Endpoints are activated as needed. Access token and refresh token must be provided as a query parameters.
pub async fn create_transfer_task(
    configuration: &configuration::Configuration,
    client_id: &str,
    access_token: &str,
    refresh_token: &str,
    req_create_transfer: Option<models::ReqCreateTransfer>,
) -> Result<models::RespTransferTask, Error<CreateTransferTaskError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_client_id = client_id;
    let p_query_access_token = access_token;
    let p_query_refresh_token = refresh_token;
    let p_body_req_create_transfer = req_create_transfer;

    let uri_str = format!(
        "{}/v3/globus-proxy/transfers/{client_id}",
        configuration.base_path,
        client_id = crate::apis::urlencode(p_path_client_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("access_token", &p_query_access_token.to_string())]);
    req_builder = req_builder.query(&[("refresh_token", &p_query_refresh_token.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_req_create_transfer);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespTransferTask`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespTransferTask`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTransferTaskError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve a transfer task given the task Id. Access token and refresh token must be provided as a query parameters.
pub async fn get_transfer_task(
    configuration: &configuration::Configuration,
    client_id: &str,
    task_id: &str,
    access_token: &str,
    refresh_token: &str,
) -> Result<models::RespTransferTask, Error<GetTransferTaskError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_client_id = client_id;
    let p_path_task_id = task_id;
    let p_query_access_token = access_token;
    let p_query_refresh_token = refresh_token;

    let uri_str = format!(
        "{}/v3/globus-proxy/transfers/{client_id}/{task_id}",
        configuration.base_path,
        client_id = crate::apis::urlencode(p_path_client_id),
        task_id = crate::apis::urlencode(p_path_task_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("access_token", &p_query_access_token.to_string())]);
    req_builder = req_builder.query(&[("refresh_token", &p_query_refresh_token.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespTransferTask`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespTransferTask`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTransferTaskError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
