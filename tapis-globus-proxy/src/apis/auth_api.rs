/*
 * Tapis Globus Proxy API
 *
 * The Tapis Globus Proxy API proxies calls to Globus coming from a Tapis service.
 *
 * The version of the OpenAPI document: 1.3.0
 * Contact: cicsupport@tacc.utexas.edu
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`check_tokens`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CheckTokensError {
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_auth_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthInfoError {
    Status404(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tokens`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokensError {
    Status407(models::RespBasic),
    Status500(models::RespBasic),
    UnknownValue(serde_json::Value),
}

/// Given an endpoint and a pair of tokens refresh the pair as needed. Return the refreshed token pair which may be the same as the provided pair. Access and refresh tokens must be provided as query parameters.
pub async fn check_tokens(
    configuration: &configuration::Configuration,
    client_id: &str,
    endpoint_id: &str,
    access_token: &str,
    refresh_token: &str,
) -> Result<models::RespAuthTokens, Error<CheckTokensError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_client_id = client_id;
    let p_path_endpoint_id = endpoint_id;
    let p_query_access_token = access_token;
    let p_query_refresh_token = refresh_token;

    let uri_str = format!(
        "{}/v3/globus-proxy/auth/check_tokens/{client_id}/{endpoint_id}",
        configuration.base_path,
        client_id = crate::apis::urlencode(p_path_client_id),
        endpoint_id = crate::apis::urlencode(p_path_endpoint_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("access_token", &p_query_access_token.to_string())]);
    req_builder = req_builder.query(&[("refresh_token", &p_query_refresh_token.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespAuthTokens`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespAuthTokens`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CheckTokensError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Given a Globus Client Id return the authorization URL that can be used by an end-user to authenticate and obtain a *Native App Authorization Code*.
pub async fn get_auth_info(
    configuration: &configuration::Configuration,
    client_id: &str,
    endpoint_id: &str,
) -> Result<models::RespGlobusAuthInfo, Error<GetAuthInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_client_id = client_id;
    let p_path_endpoint_id = endpoint_id;

    let uri_str = format!(
        "{}/v3/globus-proxy/auth/url/{client_id}/{endpoint_id}",
        configuration.base_path,
        client_id = crate::apis::urlencode(p_path_client_id),
        endpoint_id = crate::apis::urlencode(p_path_endpoint_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespGlobusAuthInfo`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespGlobusAuthInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAuthInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Exchange a Globus *Native App Authorization Code* for a pair of access and refresh tokens.
pub async fn get_tokens(
    configuration: &configuration::Configuration,
    client_id: &str,
    session_id: &str,
    auth_code: &str,
) -> Result<models::RespAuthTokens, Error<GetTokensError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_client_id = client_id;
    let p_path_session_id = session_id;
    let p_path_auth_code = auth_code;

    let uri_str = format!(
        "{}/v3/globus-proxy/auth/tokens/{client_id}/{session_id}/{auth_code}",
        configuration.base_path,
        client_id = crate::apis::urlencode(p_path_client_id),
        session_id = crate::apis::urlencode(p_path_session_id),
        auth_code = crate::apis::urlencode(p_path_auth_code)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespAuthTokens`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespAuthTokens`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTokensError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
