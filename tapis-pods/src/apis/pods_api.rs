/*
 * Tapis Pods Service
 *
 *  The Pods Service is a web service and distributed computing platform providing pods-as-a-service (PaaS). The service  implements a message broker and processor model that requests pods, alongside a health module to poll for pod data, including logs, status, and health. The primary use of this service is to have quick to deploy long-lived services based on Docker images that are exposed via HTTP or TCP endpoints listed by the API.  **The Pods service provides functionality for two types of pod solutions:**  * **Templated Pods** for run-as-is popular images. Neo4J is one example, the template manages TCP ports, user creation, and permissions.  * **Custom Pods** for arbitrary docker images with less functionality. In this case we will expose port 5000 and do nothing else.   The live-docs act as the most up-to-date API reference. Visit the [documentation for more information](https://tapis.readthedocs.io/en/latest/technical/pods.html).
 *
 * The version of the OpenAPI document: 1.9.0
 * Contact: cicsupport@tacc.utexas.edu
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`create_pod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePodError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_pod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeletePodError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`exec_pod_commands`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExecPodCommandsError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_derived_pod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDerivedPodError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPodError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pod_credentials`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPodCredentialsError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pod_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPodLogsError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_pods`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPodsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_auth`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodAuthError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_auth_callback`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodAuthCallbackError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`restart_pod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestartPodError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`save_pod_as_template_tag`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SavePodAsTemplateTagError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_pod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartPodError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stop_pod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopPodError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_pod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdatePodError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_to_pod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadToPodError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// Create a pod with inputted information.  Notes: - Author will be given ADMIN level permissions to the pod. - status_requested defaults to \"ON\". So pod will immediately begin creation.  Returns new pod object.
pub async fn create_pod(
    configuration: &configuration::Configuration,
    new_pod: models::NewPod,
) -> Result<models::PodResponse, Error<CreatePodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_new_pod = new_pod;

    let uri_str = format!("{}/pods", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    req_builder = req_builder.json(&p_body_new_pod);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PodResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PodResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreatePodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete a pod.  Returns \"\".
pub async fn delete_pod(
    configuration: &configuration::Configuration,
    pod_id: &str,
) -> Result<models::PodDeleteResponse, Error<DeletePodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pod_id = pod_id;

    let uri_str = format!(
        "{}/pods/{pod_id}",
        configuration.base_path,
        pod_id = p_path_pod_id.to_string()
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PodDeleteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PodDeleteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeletePodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Execute one or more commands in a pod.  Accepts either: - Single command: [\"sleep\", \"5\"] - Multiple commands: [[\"sleep\", \"5\"], [\"echo\", \"hello\"]]  Executes commands synchronously in the pod: - Each command runs sequentially - Total request time = sum of all command execution times - Request remains open until all commands complete - Returns consolidated results for all commands  Response includes: - Individual command outputs - Success/failure status - Execution duration
pub async fn exec_pod_commands(
    configuration: &configuration::Configuration,
    pod_id: &str,
    execute_pod_commands: models::ExecutePodCommands,
) -> Result<serde_json::Value, Error<ExecPodCommandsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pod_id = pod_id;
    let p_body_execute_pod_commands = execute_pod_commands;

    let uri_str = format!(
        "{}/pods/{pod_id}/exec",
        configuration.base_path,
        pod_id = p_path_pod_id.to_string()
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    req_builder = req_builder.json(&p_body_execute_pod_commands);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExecPodCommandsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Derive a pod's final definition if templates are used.  Returns final pod definition to be used for pod creation.
pub async fn get_derived_pod(
    configuration: &configuration::Configuration,
    pod_id: &str,
) -> Result<models::PodResponse, Error<GetDerivedPodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pod_id = pod_id;

    let uri_str = format!(
        "{}/pods/{pod_id}/derived",
        configuration.base_path,
        pod_id = p_path_pod_id.to_string()
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PodResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PodResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDerivedPodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a pod.  Returns retrieved pod object.
pub async fn get_pod(
    configuration: &configuration::Configuration,
    pod_id: &str,
) -> Result<models::PodResponse, Error<GetPodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pod_id = pod_id;

    let uri_str = format!(
        "{}/pods/{pod_id}",
        configuration.base_path,
        pod_id = p_path_pod_id.to_string()
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PodResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PodResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the credentials created for a pod.  Note: - These credentials are used in the case of templated pods, but for custom pods they're not.  Returns user accessible credentials.
pub async fn get_pod_credentials(
    configuration: &configuration::Configuration,
    pod_id: &str,
) -> Result<models::PodCredentialsResponse, Error<GetPodCredentialsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pod_id = pod_id;

    let uri_str = format!(
        "{}/pods/{pod_id}/credentials",
        configuration.base_path,
        pod_id = p_path_pod_id.to_string()
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PodCredentialsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PodCredentialsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPodCredentialsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a pods stdout logs and action_logs.  Note: - Pod logs are only retrieved while pod is running. - If a pod is restarted or turned off and then on, the logs will be reset. - Action logs are detailed logs of actions taken on the pod.  Returns pod stdout logs and action logs.
pub async fn get_pod_logs(
    configuration: &configuration::Configuration,
    pod_id: &str,
) -> Result<models::PodLogsResponse, Error<GetPodLogsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pod_id = pod_id;

    let uri_str = format!(
        "{}/pods/{pod_id}/logs",
        configuration.base_path,
        pod_id = p_path_pod_id.to_string()
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PodLogsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PodLogsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPodLogsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all pods in your respective tenant and site that you have READ or higher access to.  Returns a list of pods.
pub async fn list_pods(
    configuration: &configuration::Configuration,
) -> Result<models::PodsResponse, Error<ListPodsError>> {
    let uri_str = format!("{}/pods", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PodsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PodsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListPodsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Auth endpoint for each pod. When a networking object defines tapis_auth=True, this endpoint manages auth.  Traefik has a forwardAuth middleware for http routes. This redirects users, auth happens, if traefik gets 200 then traefik allows user to endpoint. Auth flow for a user getting to \"fastapi hello world\" pod at https://fastapi.pods.tacc.tapis.io.   1) User navigates to https://fastapi.pods.tacc.tapis.io   2) Traefik redirects user to https://tacc.tapis.io/v3/pods/fastapi/auth   3) Check if logged in via cookies, if logged in, respond 200 + set user defined headers. Otherwise...   4) Pods service creates client in correct tenant for user or updates client if it already exists. (we expect only one client in use at a time)   5) With client the /auth endpoint redirects users to https://tacc.tapis.io/v3/oauth2/authorize?client_id={client_id}&redirect_uri={callback_url}&response_type=code   6) User logs in via browser, authorizes client, redirects to callback_url at https://tacc.tapis.io/v3/pods/fastapi/auth/callback?code=CodeHere   7) Callback url exchanges code for token, gets username from token, sets X-Tapis-Token cookies, sets response headers according to tapis_auth_response_headers   8) User gets redirected back to https://fastapi.pods.tacc.tapis.io/{tapis_auth_return_path}, Traefik starts forwardAuth, user at this point should be authenticated   9) Auth endpoint responds with 200, sets headers specified by networking stanza, and users gets to fastapi hello world response.  users can specify:  - tapis_auth=True/False - Turns on auth  - tapis_auth_response_headers - dict[str] - headers to set on response and their values  - tapis_auth_allowed_users - list[str] - list of tapis users allowed to access pod  - tapis_auth_return_path - str - uri to return to after auth, default is \"passthrough\", which we save in cookies(?) and return to. x-forwarded-host?   - response headers need to be slightly modifiable to allow for different application requirements  - for example we have to pass username, but many apps require @email.bit, so user must be able to append to user.  - tapis_auth_response_headers: {\"X-Tapis-Username\": \"<<tapisusername>>@tapis.io\", \"FROM\": \"pods auth endpoint from <<tenant>>.<<site>>\", \"OAUTH2_USERNAME_KEY\": \"username\"}   - tapis_auth_allowed_users, checks username against .lower() of username list to make sure it's in list. otherwise deny
pub async fn pod_auth(
    configuration: &configuration::Configuration,
    pod_id_net: &str,
) -> Result<models::PodResponse, Error<PodAuthError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pod_id_net = pod_id_net;

    let uri_str = format!(
        "{}/pods/{pod_id_net}/auth",
        configuration.base_path,
        pod_id_net = p_path_pod_id_net.to_string()
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PodResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PodResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PodAuthError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn pod_auth_callback(
    configuration: &configuration::Configuration,
    pod_id_net: &str,
) -> Result<models::PodResponse, Error<PodAuthCallbackError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pod_id_net = pod_id_net;

    let uri_str = format!(
        "{}/pods/{pod_id_net}/auth/callback",
        configuration.base_path,
        pod_id_net = p_path_pod_id_net.to_string()
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PodResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PodResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PodAuthCallbackError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Restart a pod.  Note: - Sets status_requested to RESTART. If pod status gets to STOPPED, status_requested will be flipped to ON. Health should then create new pod. - If grab_latest_template_tag is True, attempts to grab the latest version of the template tag if the pod has a template.  Returns updated pod object.
pub async fn restart_pod(
    configuration: &configuration::Configuration,
    pod_id: &str,
    grab_latest_template_tag: Option<bool>,
) -> Result<models::PodResponse, Error<RestartPodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pod_id = pod_id;
    let p_query_grab_latest_template_tag = grab_latest_template_tag;

    let uri_str = format!(
        "{}/pods/{pod_id}/restart",
        configuration.base_path,
        pod_id = p_path_pod_id.to_string()
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_grab_latest_template_tag {
        req_builder = req_builder.query(&[("grab_latest_template_tag", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PodResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PodResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RestartPodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Endpoint takes pod_id and derives a pod_definition to create a template tag from it. Allows users to save the configuration of a particular pod as a template tag.  POST data contains location to save the tag and tag creation data  Return the template tag object.
pub async fn save_pod_as_template_tag(
    configuration: &configuration::Configuration,
    pod_id_net: &str,
    new_template_tag_from_pod: models::NewTemplateTagFromPod,
) -> Result<models::TemplateTagResponse, Error<SavePodAsTemplateTagError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pod_id_net = pod_id_net;
    let p_body_new_template_tag_from_pod = new_template_tag_from_pod;

    let uri_str = format!(
        "{}/pods/{pod_id_net}/save_pod_as_template_tag",
        configuration.base_path,
        pod_id_net = p_path_pod_id_net.to_string()
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    req_builder = req_builder.json(&p_body_new_template_tag_from_pod);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TemplateTagResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TemplateTagResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SavePodAsTemplateTagError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Start a pod.  Note: - Sets status_requested to ON. Pod will attempt to deploy.  Returns updated pod object.
pub async fn start_pod(
    configuration: &configuration::Configuration,
    pod_id: &str,
) -> Result<models::PodResponse, Error<StartPodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pod_id = pod_id;

    let uri_str = format!(
        "{}/pods/{pod_id}/start",
        configuration.base_path,
        pod_id = p_path_pod_id.to_string()
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PodResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PodResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartPodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Stop a pod.  Note: - Sets status_requested to OFF. Pod will attempt to get to STOPPED status unless start_pod is ran.  Returns updated pod object.
pub async fn stop_pod(
    configuration: &configuration::Configuration,
    pod_id: &str,
) -> Result<models::PodResponse, Error<StopPodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pod_id = pod_id;

    let uri_str = format!(
        "{}/pods/{pod_id}/stop",
        configuration.base_path,
        pod_id = p_path_pod_id.to_string()
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PodResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PodResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StopPodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update a pod.  Note: - Pod will not be restarted, you must restart the pod for any pod-related changes to proliferate.  Returns updated pod object.
pub async fn update_pod(
    configuration: &configuration::Configuration,
    pod_id: &str,
    update_pod: models::UpdatePod,
) -> Result<models::PodResponse, Error<UpdatePodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pod_id = pod_id;
    let p_body_update_pod = update_pod;

    let uri_str = format!(
        "{}/pods/{pod_id}",
        configuration.base_path,
        pod_id = p_path_pod_id.to_string()
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    req_builder = req_builder.json(&p_body_update_pod);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PodResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PodResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdatePodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Upload a file to a specific path inside the pod using Kubernetes exec/copy (chunked streaming, no temp file).
pub async fn upload_to_pod(
    configuration: &configuration::Configuration,
    pod_id: &str,
    file: std::path::PathBuf,
    dest_path: &str,
) -> Result<serde_json::Value, Error<UploadToPodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pod_id = pod_id;
    let p_form_file = file;
    let p_form_dest_path = dest_path;

    let uri_str = format!(
        "{}/pods/{pod_id}/upload_to_pod",
        configuration.base_path,
        pod_id = crate::apis::urlencode(p_path_pod_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }    let mut multipart_form = reqwest::multipart::Form::new();
    let file_bytes = std::fs::read(&p_form_file)?;
    let file_name = p_form_file
        .file_name()
        .unwrap_or_default()
        .to_string_lossy()
        .to_string();
    let file_part = reqwest::multipart::Part::bytes(file_bytes).file_name(file_name);
    multipart_form = multipart_form
        .part("file", file_part)
        .text("dest_path", p_form_dest_path.to_string());
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UploadToPodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
